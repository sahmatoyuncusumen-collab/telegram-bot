import logging
import random
import os
import psycopg2
import datetime
import sys
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes, MessageHandler, filters
from telegram.constants import ChatType

# Logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# --- BAZA V∆è ∆èSAS D∆èYƒ∞≈û∆èNL∆èR ---
DATABASE_URL = os.environ.get("DATABASE_URL")
TOKEN = os.environ.get("TELEGRAM_TOKEN")

# --- T∆èHL√úK∆èSƒ∞ZLƒ∞K YOXLAMASI ---
def run_pre_flight_checks():
    if not DATABASE_URL or not TOKEN:
        print("--- X∆èTA ---"); print("DATABASE_URL v…ô ya TELEGRAM_TOKEN tapƒ±lmadƒ±."); print("Bu skript yalnƒ±z d√ºzg√ºn konfiqurasiya edilmi≈ü Render serverind…ô i≈ül…ôm…ôlidir."); sys.exit(1)
    print("B√ºt√ºn konfiqurasiya d…ôyi≈ü…ônl…ôri m√∂vcuddur. Bot ba≈üladƒ±lƒ±r...")

# --- BAZA FUNKSƒ∞YASI ---
def init_db():
    try:
        conn = psycopg2.connect(DATABASE_URL, sslmode='require')
        cur = conn.cursor()
        cur.execute("CREATE TABLE IF NOT EXISTS message_counts (id SERIAL PRIMARY KEY, chat_id BIGINT NOT NULL, user_id BIGINT NOT NULL, username TEXT NOT NULL, message_timestamp TIMESTAMPTZ NOT NULL );")
        conn.commit(); cur.close(); conn.close()
        print("Veril…ônl…ôr bazasƒ± c…ôdv…ôli hazƒ±rdƒ±r.")
    except Exception as e:
        print(f"Baza yaradƒ±lark…ôn x…ôta: {e}")

# --- M∆èZMUN Sƒ∞YAHILARI ---
QUIZ_QUESTIONS = [
    {'question': 'Az…ôrbaycanƒ±n paytaxtƒ± haradƒ±r?', 'options': ['G…ônc…ô', 'Sumqayƒ±t', 'Bakƒ±', 'Nax√ßƒ±van'], 'correct': 'Bakƒ±'},
    {'question': 'Hansƒ± planet "Qƒ±rmƒ±zƒ± Planet" kimi tanƒ±nƒ±r?', 'options': ['Venera', 'Mars', 'Yupiter', 'Saturn'], 'correct': 'Mars'},
    {'question': 'D√ºnyanƒ±n …ôn h√ºnd√ºr daƒüƒ± hansƒ±dƒ±r?', 'options': ['K2', 'Everest', 'Makalu', 'Lhotse'], 'correct': 'Everest'},
    {'question': '∆ès…ôrl…ôrini Nizami G…ônc…ôvi imzasƒ± il…ô yazan ≈üairin …ôsl adƒ± n…ôdir?', 'options': ['ƒ∞lyas Yusif oƒülu', 'M…ôh…ômm…ôd F√ºzuli', 'ƒ∞mad…ôddin N…ôsimi', '∆èliaƒüa Vahid'], 'correct': 'ƒ∞lyas Yusif oƒülu'},
    {'question': 'Bir il …ôrzind…ô ne√ß…ô ayda 31 g√ºn var?', 'options': ['6', '7', '8', '5'], 'correct': '7'},
    {'question': 'Leonardo da Vin√ßinin ≈üah …ôs…ôri olan "Mona Liza" tablosu hazƒ±rda hansƒ± muzeyd…ô s…ôrgil…ônir?', 'options': ['Britaniya Muzeyi', 'Vatikan Muzeyi', 'Ermitaj', 'Luvr Muzeyi'], 'correct': 'Luvr Muzeyi'}
]
RIDDLES = [{'riddle': 'Aƒüzƒ± var, dili yox, danƒ±≈üdƒ±qca cana g…ôlir. Bu n…ôdir?', 'answers': ['kitab']},{'riddle': 'Gec…ô yaranar, s…ôh…ôr it…ôr. Bu n…ôdir?', 'answers': ['yuxu', 'r√∂ya']},{'riddle': 'Bir qala√ßam var, i√ßi dolu qƒ±zƒ±lca. Bu n…ôdir?', 'answers': ['nar']},{'riddle': 'N…ô q…ôd…ôr √ßox olsa, o q…ôd…ôr az g√∂r…ôrs…ôn. Bu n…ôdir?', 'answers': ['qaranlƒ±q']},{'riddle': 'M…ônim ≈ü…ôh…ôrl…ôrim var, amma evim yoxdur. Me≈ü…ôl…ôrim var, amma aƒüacƒ±m yoxdur. Sularƒ±m var, amma balƒ±ƒüƒ±m yoxdur. M…ôn n…ôy…ôm?', 'answers': ['x…ôrit…ô']},{'riddle': 'H…ôr zaman g…ôlir, amma he√ß vaxt g…ôlib √ßatmƒ±r. Bu n…ôdir?', 'answers': ['sabah']},{'riddle': 'H…ôr k…ôsin sahib olduƒüu, amma he√ß kimin itir…ô bilm…ôdiyi ≈üey n…ôdir?', 'answers': ['k√∂lg…ô']}]
NORMAL_TRUTH_QUESTIONS = ["U≈üaqlƒ±qda …ôn b√∂y√ºk qorxun n…ô idi?","H…ôyatƒ±nda …ôn √ßox pe≈üman olduƒüun ≈üey?","He√ß kimin bilm…ôdiyi bir bacarƒ±ƒüƒ±n varmƒ±?","Bu qrupda …ôn √ßox g√ºv…ôndiyin insan kimdir?","Bir g√ºnl√ºk g√∂r√ºnm…ôz olsaydƒ±n n…ô ed…ôrdin?","∆èn √ßox sevdiyin film hansƒ±dƒ±r v…ô niy…ô?","∆èn utancverici l…ôq…ôbin n…ô olub?","Valideynl…ôrin…ô dediyin …ôn b√∂y√ºk yalan n…ô olub?","He√ß hovuzun i√ßin…ô ki√ßik tualetini etmis…ôn?","Telefonundakƒ± …ôn son ≈ü…ôkil n…ôdir? (D√ºz√ºn√º de!)","∆èg…ôr heyvan olsaydƒ±n, hansƒ± heyvan olardƒ±n v…ô niy…ô?","ƒ∞ndiy…ô q…ôd…ôr aldƒ±ƒüƒ±n …ôn pis h…ôdiyy…ô n…ô olub?","He√ß kim…ô dem…ôdiyin bir sirrin n…ôdir?","Qrupdakƒ± birinin yerind…ô olmaq ist…ôs…ôydin, bu kim olardƒ±?","∆èn q…ôrib…ô yem…ôk v…ôrdi≈üin n…ôdir?","He√ß sosial media profilini gizlic…ô izl…ôdiyin (stalk etdiyin) biri olub?","S…ôni n…ô aƒülada bil…ôr?","Bir g√ºn…ô 1 milyon dollar x…ôrcl…ôm…ôli olsaydƒ±n, n…ôy…ô x…ôrcl…ôy…ôrdin?"]
NORMAL_DARE_TASKS = ["Profil ≈ü…ôklini 1 saatlƒ±q qrupdakƒ± …ôn son g√∂nd…ôril…ôn ≈ü…ôkil il…ô d…ôyi≈üdir.","Qrupdakƒ± birin…ô s…ôsli mesajla mahnƒ± oxu.","∆èlifbanƒ± sondan …ôvv…ôl…ô doƒüru s√ºr…ôtli ≈ü…ôkild…ô say.","Otaƒüƒ±ndakƒ± …ôn q…ôrib…ô …ô≈üyanƒ±n ≈ü…ôklini √ß…ôkib qrupa g√∂nd…ôr.","Telefonunun klaviaturasƒ±nƒ± 10 d…ôqiq…ôlik t…ôrs d√ºz (saƒüdan sola) istifad…ô et.","Qrupdakƒ± birin…ô icaz…ô ver, s…ônin √º√ß√ºn ƒ∞nstagram-da bir status payla≈üsƒ±n.","∆èn yaxƒ±n p…ônc…ôr…ôd…ôn √ß√∂l…ô \"M…ôn robotam!\" dey…ô qƒ±≈üqƒ±r.","Qrupa telefonunun ekran ≈ü…ôklini (screenshot) g√∂nd…ôr.","Bir qa≈üƒ±q q…ôhv…ô v…ô ya duz ye.","N√∂vb…ôti 3 d…ôqiq…ô …ôrzind…ô ancaq ≈üeir dili il…ô danƒ±≈ü.","∆èn √ßox z…ôhl…ôn ged…ôn mahnƒ±nƒ± qrupa g√∂nd…ôr.","G√∂zl…ôrin baƒülƒ± halda √∂z portretini √ß…ôkm…ôy…ô √ßalƒ±≈ü v…ô qrupa at.","Qrupdan birin…ô z…ông et v…ô ona q…ôrib…ô bir l…ôtif…ô danƒ±≈ü.","ƒ∞ki f…ôrqli i√ßkini (m…ôs…ôl…ôn, kola v…ô s√ºd) qarƒ±≈üdƒ±rƒ±b bir qurtum i√ß.","H…ôr k…ôsin g√∂r…ô bil…ôc…ôyi bir yerd…ô 30 saniy…ô robot kimi r…ôqs et.","∆èn son aldƒ±ƒüƒ±n mesaja \"OK, ancaq …ôvv…ôlc…ô kartoflarƒ± soy\" dey…ô cavab yaz."]

def get_rank_title(count: int) -> str:
    if count <= 100: return "Yeni √úzv üë∂"
    elif count <= 500: return "Daimi Sakin üë®‚Äçüíª"
    elif count <= 1000: return "Qrup S√∂hb…ôt√ßili üó£Ô∏è"
    elif count <= 2500: return "Qrup ∆èfsan…ôsi üëë"
    else: return "S√∂hb…ôt Tanrƒ±sƒ± ‚ö°Ô∏è"
    
async def welcome_new_members(update: Update, context: ContextTypes.DEFAULT_TYPE):
    #... (kod eyni qalƒ±r)
    pass
# B√ºt√ºn k√∂hn…ô funksiyalar a≈üaƒüƒ±dakƒ± tam kodda m√∂vcuddur

# --- YENƒ∞ ∆èMR FUNKSƒ∞YASI ---
async def viktorina_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Yeni viktorina oyununu ba≈üladƒ±r."""
    chat_id = update.message.chat_id
    if context.chat_data.get('quiz_active'):
        await update.message.reply_text("Artƒ±q aktiv bir viktorina var! Z…ôhm…ôt olmasa, …ôvv…ôlc…ô onu cavablandƒ±rƒ±n.")
        return

    question_data = random.choice(QUIZ_QUESTIONS)
    question = question_data['question']
    options = question_data['options']
    correct_answer = question_data['correct']

    random.shuffle(options) # Cavablarƒ±n yerini h…ôr d…ôf…ô d…ôyi≈üir

    context.chat_data['correct_quiz_answer'] = correct_answer
    context.chat_data['quiz_active'] = True
    
    keyboard = [[InlineKeyboardButton(option, callback_data=f"quiz_{option}")] for option in options]
    reply_markup = InlineKeyboardMarkup(keyboard)

    message = await update.message.reply_text(f"Viktorina ba≈üladƒ±! üß†\n\n**Sual:** {question}", parse_mode='Markdown', reply_markup=reply_markup)
    context.chat_data['quiz_message_id'] = message.message_id


async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query, user, data = update.callback_query, update.callback_query.from_user, update.callback_query.data
    await query.answer()

    # YENƒ∞: Viktorina cavablarƒ±nƒ± yoxlayan m…ôntiq
    if data.startswith("quiz_"):
        if not context.chat_data.get('quiz_active'):
            await query.answer("Bu viktorina artƒ±q bitib.", show_alert=True)
            return

        chosen_answer = data.split('_', 1)[1]
        correct_answer = context.chat_data['correct_quiz_answer']

        if chosen_answer == correct_answer:
            await query.answer("D√ºzd√ºr!", show_alert=False)
            await context.bot.edit_message_text(
                chat_id=query.message.chat_id,
                message_id=context.chat_data['quiz_message_id'],
                text=f"{query.message.text}\n\n---\nü•≥ Qalib: {user.first_name}!\n‚úÖ D√ºzg√ºn cavab: **{correct_answer}**",
                parse_mode='Markdown'
            )
            # Oyun statusunu t…ômizl…ôyirik
            del context.chat_data['quiz_active']
            del context.chat_data['correct_quiz_answer']
            del context.chat_data['quiz_message_id']
        else:
            await query.answer("S…ôhv cavab! Ba≈üqasƒ± c…ôhd etsin. üò•", show_alert=True)
        return

    # Tapmaca v…ô "Doƒüruluq C…ôsar…ôt" m…ôntiqi olduƒüu kimi qalƒ±r
    # ... (a≈üaƒüƒ±dakƒ± tam kodda m√∂vcuddur)

def main() -> None:
    #...
    application.add_handler(CommandHandler("viktorina", viktorina_command, filters=group_filter))
    #...

# --- B√ºt√ºn D…ôyi≈üiklikl…ôrl…ô Birlikd…ô Tam Kod (BUNU KOPYALAYIN) ---
import logging, random, os, psycopg2, datetime, sys
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes, MessageHandler, filters
from telegram.constants import ChatType

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

DATABASE_URL = os.environ.get("DATABASE_URL")
TOKEN = os.environ.get("TELEGRAM_TOKEN")

def run_pre_flight_checks():
    if not DATABASE_URL or not TOKEN:
        print("--- X∆èTA ---"); print("DATABASE_URL v…ô ya TELEGRAM_TOKEN tapƒ±lmadƒ±."); sys.exit(1)
    print("B√ºt√ºn konfiqurasiya d…ôyi≈ü…ônl…ôri m√∂vcuddur. Bot ba≈üladƒ±lƒ±r...")

def init_db():
    try:
        conn = psycopg2.connect(DATABASE_URL, sslmode='require')
        cur = conn.cursor()
        cur.execute("CREATE TABLE IF NOT EXISTS message_counts (id SERIAL PRIMARY KEY, chat_id BIGINT NOT NULL, user_id BIGINT NOT NULL, username TEXT NOT NULL, message_timestamp TIMESTAMPTZ NOT NULL );")
        conn.commit(); cur.close(); conn.close()
        print("Veril…ônl…ôr bazasƒ± c…ôdv…ôli hazƒ±rdƒ±r.")
    except Exception as e:
        print(f"Baza yaradƒ±lark…ôn x…ôta: {e}")

QUIZ_QUESTIONS = [{'question': 'Az…ôrbaycanƒ±n paytaxtƒ± haradƒ±r?', 'options': ['G…ônc…ô', 'Sumqayƒ±t', 'Bakƒ±', 'Nax√ßƒ±van'], 'correct': 'Bakƒ±'},{'question': 'Hansƒ± planet "Qƒ±rmƒ±zƒ± Planet" kimi tanƒ±nƒ±r?', 'options': ['Venera', 'Mars', 'Yupiter', 'Saturn'], 'correct': 'Mars'},{'question': 'D√ºnyanƒ±n …ôn h√ºnd√ºr daƒüƒ± hansƒ±dƒ±r?', 'options': ['K2', 'Everest', 'Makalu', 'Lhotse'], 'correct': 'Everest'},{'question': '∆ès…ôrl…ôrini Nizami G…ônc…ôvi imzasƒ± il…ô yazan ≈üairin …ôsl adƒ± n…ôdir?', 'options': ['ƒ∞lyas Yusif oƒülu', 'M…ôh…ômm…ôd F√ºzuli', 'ƒ∞mad…ôddin N…ôsimi', '∆èliaƒüa Vahid'], 'correct': 'ƒ∞lyas Yusif oƒülu'},{'question': 'Bir il …ôrzind…ô ne√ß…ô ayda 31 g√ºn var?', 'options': ['6', '7', '8', '5'], 'correct': '7'},{'question': 'Leonardo da Vin√ßinin ≈üah …ôs…ôri olan "Mona Liza" tablosu hazƒ±rda hansƒ± muzeyd…ô s…ôrgil…ônir?', 'options': ['Britaniya Muzeyi', 'Vatikan Muzeyi', 'Ermitaj', 'Luvr Muzeyi'], 'correct': 'Luvr Muzeyi'}]
RIDDLES = [{'riddle': 'Aƒüzƒ± var, dili yox, danƒ±≈üdƒ±qca cana g…ôlir. Bu n…ôdir?', 'answers': ['kitab']},{'riddle': 'Gec…ô yaranar, s…ôh…ôr it…ôr. Bu n…ôdir?', 'answers': ['yuxu', 'r√∂ya']},{'riddle': 'Bir qala√ßam var, i√ßi dolu qƒ±zƒ±lca. Bu n…ôdir?', 'answers': ['nar']},{'riddle': 'N…ô q…ôd…ôr √ßox olsa, o q…ôd…ôr az g√∂r…ôrs…ôn. Bu n…ôdir?', 'answers': ['qaranlƒ±q']},{'riddle': 'M…ônim ≈ü…ôh…ôrl…ôrim var, amma evim yoxdur. Me≈ü…ôl…ôrim var, amma aƒüacƒ±m yoxdur. Sularƒ±m var, amma balƒ±ƒüƒ±m yoxdur. M…ôn n…ôy…ôm?', 'answers': ['x…ôrit…ô']},{'riddle': 'H…ôr zaman g…ôlir, amma he√ß vaxt g…ôlib √ßatmƒ±r. Bu n…ôdir?', 'answers': ['sabah']},{'riddle': 'H…ôr k…ôsin sahib olduƒüu, amma he√ß kimin itir…ô bilm…ôdiyi ≈üey n…ôdir?', 'answers': ['k√∂lg…ô']}]
NORMAL_TRUTH_QUESTIONS = ["U≈üaqlƒ±qda …ôn b√∂y√ºk qorxun n…ô idi?","H…ôyatƒ±nda …ôn √ßox pe≈üman olduƒüun ≈üey?","He√ß kimin bilm…ôdiyi bir bacarƒ±ƒüƒ±n varmƒ±?","Bu qrupda …ôn √ßox g√ºv…ôndiyin insan kimdir?","Bir g√ºnl√ºk g√∂r√ºnm…ôz olsaydƒ±n n…ô ed…ôrdin?","∆èn √ßox sevdiyin film hansƒ±dƒ±r v…ô niy…ô?","∆èn utancverici l…ôq…ôbin n…ô olub?","Valideynl…ôrin…ô dediyin …ôn b√∂y√ºk yalan n…ô olub?","He√ß hovuzun i√ßin…ô ki√ßik tualetini etmis…ôn?","Telefonundakƒ± …ôn son ≈ü…ôkil n…ôdir? (D√ºz√ºn√º de!)","∆èg…ôr heyvan olsaydƒ±n, hansƒ± heyvan olardƒ±n v…ô niy…ô?","ƒ∞ndiy…ô q…ôd…ôr aldƒ±ƒüƒ±n …ôn pis h…ôdiyy…ô n…ô olub?","He√ß kim…ô dem…ôdiyin bir sirrin n…ôdir?","Qrupdakƒ± birinin yerind…ô olmaq ist…ôs…ôydin, bu kim olardƒ±?","∆èn q…ôrib…ô yem…ôk v…ôrdi≈üin n…ôdir?","He√ß sosial media profilini gizlic…ô izl…ôdiyin (stalk etdiyin) biri olub?","S…ôni n…ô aƒülada bil…ôr?","Bir g√ºn…ô 1 milyon dollar x…ôrcl…ôm…ôli olsaydƒ±n, n…ôy…ô x…ôrcl…ôy…ôrdin?"]
NORMAL_DARE_TASKS = ["Profil ≈ü…ôklini 1 saatlƒ±q qrupdakƒ± …ôn son g√∂nd…ôril…ôn ≈ü…ôkil il…ô d…ôyi≈üdir.","Qrupdakƒ± birin…ô s…ôsli mesajla mahnƒ± oxu.","∆èlifbanƒ± sondan …ôvv…ôl…ô doƒüru s√ºr…ôtli ≈ü…ôkild…ô say.","Otaƒüƒ±ndakƒ± …ôn q…ôrib…ô …ô≈üyanƒ±n ≈ü…ôklini √ß…ôkib qrupa g√∂nd…ôr.","Telefonunun klaviaturasƒ±nƒ± 10 d…ôqiq…ôlik t…ôrs d√ºz (saƒüdan sola) istifad…ô et.","Qrupdakƒ± birin…ô icaz…ô ver, s…ônin √º√ß√ºn ƒ∞nstagram-da bir status payla≈üsƒ±n.","∆èn yaxƒ±n p…ônc…ôr…ôd…ôn √ß√∂l…ô \"M…ôn robotam!\" dey…ô qƒ±≈üqƒ±r.","Qrupa telefonunun ekran ≈ü…ôklini (screenshot) g√∂nd…ôr.","Bir qa≈üƒ±q q…ôhv…ô v…ô ya duz ye.","N√∂vb…ôti 3 d…ôqiq…ô …ôrzind…ô ancaq ≈üeir dili il…ô danƒ±≈ü.","∆èn √ßox z…ôhl…ôn ged…ôn mahnƒ±nƒ± qrupa g√∂nd…ôr.","G√∂zl…ôrin baƒülƒ± halda √∂z portretini √ß…ôkm…ôy…ô √ßalƒ±≈ü v…ô qrupa at.","Qrupdan birin…ô z…ông et v…ô ona q…ôrib…ô bir l…ôtif…ô danƒ±≈ü.","ƒ∞ki f…ôrqli i√ßkini (m…ôs…ôl…ôn, kola v…ô s√ºd) qarƒ±≈üdƒ±rƒ±b bir qurtum i√ß.","H…ôr k…ôsin g√∂r…ô bil…ôc…ôyi bir yerd…ô 30 saniy…ô robot kimi r…ôqs et.","∆èn son aldƒ±ƒüƒ±n mesaja \"OK, ancaq …ôvv…ôlc…ô kartoflarƒ± soy\" dey…ô cavab yaz."]

def get_rank_title(count: int) -> str:
    if count <= 100: return "Yeni √úzv üë∂"
    elif count <= 500: return "Daimi Sakin üë®‚Äçüíª"
    elif count <= 1000: return "Qrup S√∂hb…ôt√ßili üó£Ô∏è"
    elif count <= 2500: return "Qrup ∆èfsan…ôsi üëë"
    else: return "S√∂hb…ôt Tanrƒ±sƒ± ‚ö°Ô∏è"
async def welcome_new_members(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.message.new_chat_members: return
    new_members, chat_title = update.message.new_chat_members, update.message.chat.title
    for member in new_members:
        if member.id == context.bot.id: continue
        welcome_message = (f"Salam, [{member.first_name}](tg://user?id={member.id})! üëã\n"
                         f"**'{chat_title}'** qrupuna xo≈ü g…ôlmis…ôn!\n\n"
                         "M…ôn bu qrupun …ôyl…ônc…ô v…ô statistika botuyam. /oyun, /tapmaca v…ô ya /viktorina yaza bil…ôrsiniz.\n\n"
                         "Qrupun …ôn aktiv √ºzvl…ôrini g√∂rm…ôk √º√ß√ºn is…ô /reyting gunluk …ômrini istifad…ô et.")
        await update.message.reply_text(welcome_message, parse_mode='Markdown')
async def is_user_admin(chat_id: int, user_id: int, context: ContextTypes.DEFAULT_TYPE) -> bool:
    if chat_id == user_id: return True
    try: return user_id in [admin.user.id for admin in await context.bot.get_chat_administrators(chat_id)]
    except Exception: return False
async def ask_next_player(chat_id: int, context: ContextTypes.DEFAULT_TYPE):
    chat_data = context.chat_data
    if not chat_data.get('player_list'):
        await context.bot.send_message(chat_id, "Oyun√ßu qalmadƒ±. Oyun dayandƒ±rƒ±lƒ±r."); context.chat_data.clear(); return
    chat_data['current_player_index'] = (chat_data.get('current_player_index', -1) + 1) % len(chat_data['player_list'])
    current_player = chat_data['player_list'][chat_data['current_player_index']]
    user_id, first_name = current_player['id'], current_player['name']
    keyboard = [[InlineKeyboardButton("Doƒüruluq ‚úÖ", callback_data=f"game_truth_{user_id}"), InlineKeyboardButton("C…ôsar…ôt üòà", callback_data=f"game_dare_{user_id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await context.bot.send_message(chat_id, text=f"Sƒ±ra s…ôn…ô √ßatdƒ±, [{first_name}](tg://user?id={user_id})! Se√ßimini et:", reply_markup=reply_markup, parse_mode='Markdown')
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Salam! ü§ñ\n\nQrupda …ôyl…ônc…ô √º√ß√ºn …ômrl…ôr:\n`/oyun` - Doƒüruluq yoxsa C…ôsar…ôt?\n`/tapmaca` - Tapmaca oyunu\n`/viktorina` - Viktorina oyunu\n\nStatistika √º√ß√ºn:\n`/reyting [d√∂vr]`\n`/menim_rutbem`")
async def game_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if context.chat_data.get('game_active') or context.chat_data.get('players'):
        await update.message.reply_text("Artƒ±q aktiv bir oyun var. Yeni oyun √º√ß√ºn /dayandir yazƒ±n."); return
    keyboard = [[InlineKeyboardButton("Oyuna Qo≈üul üôã‚Äç‚ôÇÔ∏è", callback_data="register_join")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Oyun √º√ß√ºn qeydiyyat ba≈üladƒ±! Qo≈üulmaq √º√ß√ºn d√ºym…ôy…ô basƒ±n.", reply_markup=reply_markup)
async def start_game_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id, user_id = update.message.chat_id, update.message.from_user.id
    if not await is_user_admin(chat_id, user_id, context):
        await update.message.reply_text("‚õî Bu …ômri yalnƒ±z qrup adminl…ôri istifad…ô ed…ô bil…ôr."); return
    players = context.chat_data.get('players', {})
    if len(players) < 2:
        await update.message.reply_text("Oyunun ba≈ülamasƒ± √º√ß√ºn …ôn az 2 n…ôf…ôr qeydiyyatdan ke√ßm…ôlidir."); return
    context.chat_data['game_active'] = True
    player_list = list(players.values()); random.shuffle(player_list)
    context.chat_data['player_list'] = player_list
    player_names = ", ".join([p['name'] for p in player_list])
    await update.message.reply_text(f"Oyun ba≈üladƒ±! üöÄ\n\nƒ∞≈ütirak√ßƒ±lar: {player_names}\n\nƒ∞lk oyun√ßu √º√ß√ºn hazƒ±rla≈üƒ±n...")
    await ask_next_player(chat_id, context)
async def next_turn_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id, user_id = update.message.chat_id, update.message.from_user.id
    if not context.chat_data.get('game_active', False):
        await update.message.reply_text("Hazƒ±rda aktiv oyun yoxdur."); return
    if not await is_user_admin(chat_id, user_id, context):
        await update.message.reply_text("‚õî Sƒ±ranƒ± yalnƒ±z qrup adminl…ôri d…ôyi≈ü…ô bil…ôr."); return
    await update.message.reply_text("Sƒ±ra n√∂vb…ôti oyun√ßuya ke√ßir...")
    await ask_next_player(chat_id, context)
async def stop_game_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id, user_id = update.message.chat_id, update.message.from_user.id
    if not await is_user_admin(chat_id, user_id, context):
        await update.message.reply_text("‚õî Bu …ômri yalnƒ±z qrup adminl…ôri istifad…ô ed…ô bil…ôr."); return
    context.chat_data.clear()
    await update.message.reply_text("Oyun admin t…ôr…ôfind…ôn dayandƒ±rƒ±ldƒ±. B√ºt√ºn m…ôlumatlar sƒ±fƒ±rlandƒ±. Yeni oyun √º√ß√ºn /oyun yazƒ±n.")
async def join_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    if not context.chat_data.get('game_active', False):
        await update.message.reply_text("Hazƒ±rda aktiv oyun yoxdur. Yeni oyun √º√ß√ºn /oyun …ômrini g√∂zl…ôyin."); return
    context.chat_data.setdefault('players', {})[user.id] = {'id': user.id, 'name': user.first_name}
    if 'player_list' in context.chat_data: context.chat_data['player_list'].append({'id': user.id, 'name': user.first_name})
    await update.message.reply_text(f"Xo≈ü g…ôldin, {user.first_name}! S…ôn d…ô oyuna qo≈üuldun.")
async def leave_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    players = context.chat_data.get('players', {})
    if user_id not in players:
        await update.message.reply_text("Siz onsuz da oyunda deyilsiniz."); return
    del players[user_id]
    if 'player_list' in context.chat_data: context.chat_data['player_list'] = [p for p in context.chat_data['player_list'] if p['id'] != user_id]
    await update.message.reply_text(f"{update.message.from_user.first_name} oyundan ayrƒ±ldƒ±.")
    if len(players) < 2 and context.chat_data.get('game_active', False):
        await update.message.reply_text("Oyun√ßu sayƒ± 2-d…ôn az olduƒüu √º√ß√ºn oyun dayandƒ±rƒ±ldƒ±."); context.chat_data.clear()
async def tapmaca_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if context.chat_data.get('riddle_active'):
        await update.message.reply_text("Artƒ±q aktiv bir tapmaca var! Z…ôhm…ôt olmasa, …ôvv…ôlc…ô onu tapƒ±n."); return
    chosen_riddle = random.choice(RIDDLES)
    context.chat_data['riddle_answer'] = [ans.lower() for ans in chosen_riddle['answers']]
    context.chat_data['riddle_active'] = True
    keyboard = [[InlineKeyboardButton("Cavabƒ± G√∂st…ôr üí°", callback_data="skip_riddle")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Tapmaca g…ôldi! üïµÔ∏è‚Äç‚ôÇÔ∏è\n\n**{chosen_riddle['riddle']}**", parse_mode='Markdown', reply_markup=reply_markup)
async def viktorina_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.chat_id
    if context.chat_data.get('quiz_active'):
        await update.message.reply_text("Artƒ±q aktiv bir viktorina var! Z…ôhm…ôt olmasa, …ôvv…ôlc…ô onu cavablandƒ±rƒ±n."); return
    question_data = random.choice(QUIZ_QUESTIONS)
    question, correct_answer, options = question_data['question'], question_data['correct'], question_data['options']
    random.shuffle(options)
    context.chat_data['correct_quiz_answer'] = correct_answer
    context.chat_data['quiz_active'] = True
    keyboard = [[InlineKeyboardButton(option, callback_data=f"quiz_{option}")] for option in options]
    reply_markup = InlineKeyboardMarkup(keyboard)
    message = await update.message.reply_text(f"Viktorina ba≈üladƒ±! üß†\n\n**Sual:** {question}", parse_mode='Markdown', reply_markup=reply_markup)
    context.chat_data['quiz_message_id'] = message.message_id
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query, user, data = update.callback_query, update.callback_query.from_user, update.callback_query.data
    await query.answer()
    if data.startswith("quiz_"):
        if not context.chat_data.get('quiz_active'):
            await query.answer("Bu viktorina artƒ±q bitib.", show_alert=True); return
        chosen_answer = data.split('_', 1)[1]; correct_answer = context.chat_data['correct_quiz_answer']
        if chosen_answer == correct_answer:
            await query.answer("D√ºzd√ºr!", show_alert=False)
            await context.bot.edit_message_text(
                chat_id=query.message.chat_id, message_id=context.chat_data['quiz_message_id'],
                text=f"{query.message.text}\n\n---\nü•≥ Qalib: {user.first_name}!\n‚úÖ D√ºzg√ºn cavab: **{correct_answer}**",
                parse_mode='Markdown'
            )
            del context.chat_data['quiz_active']; del context.chat_data['correct_quiz_answer']; del context.chat_data['quiz_message_id']
        else:
            await query.answer("S…ôhv cavab! Ba≈üqasƒ± c…ôhd etsin. üò•", show_alert=True)
        return
    if data == "skip_riddle":
        if not context.chat_data.get('riddle_active'):
            await query.answer("Bu tapmaca artƒ±q bitib.", show_alert=True); return
        correct_answers = context.chat_data.get('riddle_answer', [])
        correct_answer_text = ", ".join(correct_answers).capitalize()
        await query.edit_message_text(text=f"{query.message.text}\n\n---\nüò• He√ß kim tapa bilm…ôdi!\n‚úÖ **D√ºzg√ºn cavab:** {correct_answer_text}\n\nYeni tapmaca √º√ß√ºn /tapmaca yazƒ±n.", parse_mode='Markdown')
        del context.chat_data['riddle_active']; del context.chat_data['riddle_answer']
        return
    if data == "register_join":
        players = context.chat_data.setdefault('players', {})
        if user.id not in players:
            players[user.id] = {'id': user.id, 'name': user.first_name}
            await query.answer("Uƒüurla qeydiyyatdan ke√ßdiniz!", show_alert=True)
            player_names = ", ".join([p['name'] for p in players.values()])
            keyboard = [[InlineKeyboardButton("Oyuna Qo≈üul üôã‚Äç‚ôÇÔ∏è", callback_data="register_join")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(f"Oyun √º√ß√ºn qeydiyyat davam edir!\n\n**Qo≈üulanlar:** {player_names}\n\nAdminin oyunu ba≈ülatmasƒ±nƒ± g√∂zl…ôyin (/baslat).", reply_markup=reply_markup, parse_mode='Markdown')
        else: await query.answer("Siz onsuz da qeydiyyatdan ke√ßmisiniz.", show_alert=True)
    elif data.startswith("game_"):
        parts = data.split('_'); action, target_user_id = parts[1], int(parts[2])
        if user.id != target_user_id: await query.answer("‚õî Bu s…ônin sƒ±ran deyil!", show_alert=True); return
        question = random.choice(NORMAL_TRUTH_QUESTIONS) if action == 'truth' else random.choice(NORMAL_DARE_TASKS)
        response_text = f"üìú {user.first_name} √º√ß√ºn **Doƒüruluq**:\n\n> {question}" if action == 'truth' else f"üî• {user.first_name} √º√ß√ºn **C…ôsar…ôt**:\n\n> {random.choice(NORMAL_DARE_TASKS)}"
        command_suggestion = "\n\n*Cavab verildikd…ôn sonra admin n√∂vb…ôti tura ke√ßm…ôk √º√ß√ºn /novbeti yazsƒ±n.*"
        await query.edit_message_text(text=response_text + command_suggestion, parse_mode='Markdown')
async def rating_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id, args = update.message.chat_id, context.args
    if not args: await update.message.reply_text("Z…ôhm…ôt olmasa, d√∂vr√º t…ôyin edin:\n`/reyting gunluk`\n`/reyting heftelik`\n`/reyting ayliq`", parse_mode='Markdown'); return
    period = args[0].lower()
    if period == "gunluk": interval, title = "1 day", "Son 24 Saatƒ±n ∆èn Aktiv √úzvl…ôri ‚òÄÔ∏è"
    elif period == "heftelik": interval, title = "7 days", "Son 7 G√ºn√ºn ∆èn Aktiv √úzvl…ôri üóìÔ∏è"
    elif period == "ayliq": interval, title = "1 month", "Son 30 G√ºn√ºn ∆èn Aktiv √úzvl…ôri üåô"
    else: await update.message.reply_text("Yanlƒ±≈ü d√∂vr. M√ºmk√ºn se√ßiml…ôr: gunluk, heftelik, ayliq"); return
    try:
        conn = psycopg2.connect(DATABASE_URL, sslmode='require')
        cur = conn.cursor()
        query = f"SELECT user_id, username, COUNT(*) as msg_count FROM message_counts WHERE chat_id = %s AND message_timestamp >= NOW() - INTERVAL '{interval}' GROUP BY user_id, username ORDER BY msg_count DESC LIMIT 10;"
        cur.execute(query, (chat_id,)); results = cur.fetchall(); cur.close(); conn.close()
        if not results: await update.message.reply_text("Bu d√∂vr √º√ß√ºn he√ß bir mesaj tapƒ±lmadƒ±."); return
        leaderboard = f"üìä **{title}**\n\n"
        for i, (user_id, username, msg_count) in enumerate(results):
            medal = ""
            if i == 0: medal = "ü•á"
            elif i == 1: medal = "ü•à"
            elif i == 2: medal = "ü•â"
            rank_title = get_rank_title(msg_count)
            leaderboard += f"{i+1}. {medal} [{username}](tg://user?id={user_id}) - `{msg_count}` msj ({rank_title})\n"
        await update.message.reply_text(leaderboard, parse_mode='Markdown', disable_web_page_preview=True)
    except Exception as e:
        logger.error(f"Reytinq alƒ±nark…ôn x…ôta: {e}"); await update.message.reply_text("Reytinq c…ôdv…ôlini hazƒ±rlayark…ôn bir x…ôta ba≈ü verdi.")
async def my_rank_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id, user_name, chat_id = update.message.from_user.id, update.message.from_user.first_name, update.message.chat_id
    try:
        conn = psycopg2.connect(DATABASE_URL, sslmode='require')
        cur = conn.cursor(); query = "SELECT COUNT(*) FROM message_counts WHERE user_id = %s AND chat_id = %s;"
        cur.execute(query, (user_id, chat_id)); result = cur.fetchone(); cur.close(); conn.close()
        total_count = result[0] if result else 0
        rank_title = get_rank_title(total_count)
        await update.message.reply_text(f"Salam, {user_name}!\n\nBu qrupdakƒ± √ºmumi mesaj sayƒ±nƒ±z: **{total_count}**\nHazƒ±rkƒ± r√ºtb…ôniz: **{rank_title}**", parse_mode='Markdown')
    except Exception as e:
        logger.error(f"≈û…ôxsi r√ºtb…ô alƒ±nark…ôn x…ôta: {e}"); await update.message.reply_text("R√ºtb…ônizi hesablayark…ôn bir x…ôta ba≈ü verdi.")
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.message.from_user or not update.message.chat.type in [ChatType.GROUP, ChatType.SUPERGROUP]: return
    user, chat_id, text = update.message.from_user, update.message.chat_id, update.message.text
    if context.chat_data.get('riddle_active'):
        correct_answers = context.chat_data.get('riddle_answer', [])
        if text and text.strip().lower() in correct_answers:
            await update.message.reply_text(f"∆èhs…ôn, [{user.first_name}](tg://user?id={user.id})! ü•≥ D√ºzg√ºn cavab tapƒ±ldƒ±! ‚úÖ", parse_mode='Markdown', reply_to_message_id=update.message.message_id)
            del context.chat_data['riddle_active']; del context.chat_data['riddle_answer']
    try:
        conn = psycopg2.connect(DATABASE_URL, sslmode='require')
        cur = conn.cursor()
        cur.execute("INSERT INTO message_counts (chat_id, user_id, username, message_timestamp) VALUES (%s, %s, %s, %s)",
                    (chat_id, user.id, user.first_name, datetime.datetime.now(datetime.timezone.utc)))
        conn.commit(); cur.close(); conn.close()
    except Exception as e:
        logger.error(f"Mesajƒ± bazaya yazark…ôn x…ôta: {e}")
def main() -> None:
    run_pre_flight_checks()
    init_db()
    application = Application.builder().token(TOKEN).build()
    group_filter = ~filters.ChatType.PRIVATE
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("oyun", game_command, filters=group_filter))
    application.add_handler(CommandHandler("baslat", start_game_command, filters=group_filter))
    application.add_handler(CommandHandler("novbeti", next_turn_command, filters=group_filter))
    application.add_handler(CommandHandler("dayandir", stop_game_command, filters=group_filter))
    application.add_handler(CommandHandler("qosul", join_command, filters=group_filter))
    application.add_handler(CommandHandler("cix", leave_command, filters=group_filter))
    application.add_handler(CommandHandler("reyting", rating_command, filters=group_filter))
    application.add_handler(CommandHandler("menim_rutbem", my_rank_command, filters=group_filter))
    application.add_handler(CommandHandler("tapmaca", tapmaca_command, filters=group_filter))
    application.add_handler(CommandHandler("viktorina", viktorina_command, filters=group_filter))
    application.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND) & group_filter, handle_message))
    application.add_handler(MessageHandler(filters.StatusUpdate.ALL & group_filter, welcome_new_members))
    application.add_handler(MessageHandler(filters.ChatType.PRIVATE & (~filters.COMMAND), start_command))
    application.add_handler(CallbackQueryHandler(button_handler))
    print("Bot i≈ü…ô d√º≈üd√º...")
    application.run_polling()
if __name__ == '__main__':
    main()
